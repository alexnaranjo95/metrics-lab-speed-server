import fs from 'fs/promises';
import path from 'path';
import type { OptimizationSettings } from '../shared/settingsSchema.js';

export interface SecurityHeadersResult {
  cspEnabled: boolean;
  trustedTypesEnabled: boolean;
  hstsEnabled: boolean;
  totalSecurityHeaders: number;
  estimatedBestPracticesImprovement: number;
}

/**
 * Generate a Cloudflare Pages _headers file with optimal caching rules
 * and comprehensive security headers for Best Practices score of 100/100.
 */
export interface EarlyHintAsset {
  path: string;
  as: 'style' | 'font' | 'image' | 'script';
  type?: string;
  crossorigin?: boolean;
}

export async function generateHeaders(
  outputDir: string, 
  settings?: OptimizationSettings,
  earlyHints?: EarlyHintAsset[]
): Promise<SecurityHeadersResult> {
  const cache = settings?.cache.durations;
  const security = settings?.security || settings?.cache?.securityHeaders;

  // Enhanced security headers for Best Practices optimization
  const securityResult: SecurityHeadersResult = {
    cspEnabled: false,
    trustedTypesEnabled: false,
    hstsEnabled: false,
    totalSecurityHeaders: 0,
    estimatedBestPracticesImprovement: 0,
  };

  const securityLines = generateSecurityHeaders(security, securityResult);

  const htmlCache = cache?.html ?? 'public, max-age=0, must-revalidate';
  const assetCache = cache?.cssJs ?? 'public, max-age=31536000, immutable';
  const fontCache = cache?.fonts ?? 'public, max-age=31536000, immutable';
  const imageHashedCache = cache?.imagesHashed ?? 'public, max-age=31536000, immutable';

  const headersContent = `# Cloudflare Pages headers - Enhanced for PageSpeed Best Practices 100/100
# Generated by MetricsLab Speed Server

# Comprehensive security headers for all pages
/*
${securityLines.join('\n')}

# HTML pages: cache briefly, revalidate
/*.html
  Cache-Control: ${htmlCache}

# Root index with security headers
/
  Cache-Control: ${htmlCache}

# Static assets with content-hashed filenames: cache forever
/assets/*
  Cache-Control: ${assetCache}
  Access-Control-Allow-Origin: *

# Fonts: cache forever with CORS headers
/assets/fonts/*
  Cache-Control: ${fontCache}
  Access-Control-Allow-Origin: *
  Access-Control-Allow-Methods: GET
  Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept

# Images: cache aggressively with optimization headers
/assets/*.webp
  Cache-Control: ${imageHashedCache}
  Vary: Accept

/assets/*.avif
  Cache-Control: ${imageHashedCache}
  Vary: Accept

/assets/*.jpg
  Cache-Control: ${imageHashedCache}

/assets/*.jpeg
  Cache-Control: ${imageHashedCache}

/assets/*.png
  Cache-Control: ${imageHashedCache}

/assets/*.svg
  Cache-Control: ${imageHashedCache}
  Content-Type: image/svg+xml

# CSS files with additional headers
/assets/*.css
  Cache-Control: ${assetCache}
  Content-Type: text/css; charset=utf-8

# JavaScript files with additional headers
/assets/*.js
  Cache-Control: ${assetCache}
  Content-Type: application/javascript; charset=utf-8
`;

  // ── Early Hints: Link preload headers for HTTP 103 ──
  let earlyHintsBlock = '';
  if (earlyHints && earlyHints.length > 0) {
    const linkHeaders = earlyHints.map(hint => {
      const parts = [`<${hint.path}>`, `rel=preload`, `as=${hint.as}`];
      if (hint.type) parts.push(`type="${hint.type}"`);
      if (hint.crossorigin) parts.push('crossorigin');
      return `  Link: ${parts.join('; ')}`;
    }).join('\n');

    earlyHintsBlock = `\n# Early Hints (HTTP 103) for critical resources\n/\n${linkHeaders}\n/index.html\n${linkHeaders}\n`;
  }

  // ── Self-hosted asset paths with immutable caching ──
  const selfHostedBlock = `
# Self-hosted JS files (content-hashed): cache forever
/js/*
  Cache-Control: public, max-age=31536000, immutable
  Content-Type: application/javascript; charset=utf-8

# Self-hosted CSS files (content-hashed): cache forever
/css/*
  Cache-Control: public, max-age=31536000, immutable
  Content-Type: text/css; charset=utf-8

# Self-hosted fonts: cache forever with CORS
/fonts/*
  Cache-Control: public, max-age=31536000, immutable
  Access-Control-Allow-Origin: *

# Self-hosted images
/images/*
  Cache-Control: public, max-age=31536000, immutable
`;

  const finalContent = headersContent + selfHostedBlock + earlyHintsBlock;

  const headersPath = path.join(outputDir, '_headers');
  await fs.writeFile(headersPath, finalContent, 'utf-8');
  console.log(`[headers] Generated enhanced _headers file at ${headersPath} (${securityResult.totalSecurityHeaders} security headers${earlyHints?.length ? `, ${earlyHints.length} early hints` : ''})`);
  
  return securityResult;
}

/**
 * Generate comprehensive security headers for Best Practices score optimization
 * Implements all security headers required for Lighthouse Best Practices 100/100
 */
function generateSecurityHeaders(
  security: any,
  result: SecurityHeadersResult
): string[] {
  const securityLines: string[] = [];

  // 1. Content Security Policy with Trusted Types (CRITICAL for Lighthouse)
  const cspDirectives = security?.cspDirectives || generateDefaultCSP();
  let csp = buildCSPHeader(cspDirectives);
  
  // CRITICAL: Add require-trusted-types-for 'script' for DOM XSS mitigation
  // This is specifically required by Lighthouse Best Practices audit
  if (!csp.includes('require-trusted-types-for')) {
    csp += '; require-trusted-types-for \'script\'';
    result.trustedTypesEnabled = true;
    result.estimatedBestPracticesImprovement += 6; // ~6 points per audit
  }
  
  securityLines.push(`  Content-Security-Policy: ${csp}`);
  result.cspEnabled = true;
  result.totalSecurityHeaders++;

  // 2. X-Content-Type-Options (prevents MIME sniffing)
  if (security?.xContentTypeOptions !== false) {
    securityLines.push('  X-Content-Type-Options: nosniff');
    result.totalSecurityHeaders++;
    result.estimatedBestPracticesImprovement += 6;
  }

  // 3. X-Frame-Options (clickjacking protection)
  const frameOptions = security?.xFrameOptions || 'DENY';
  if (frameOptions !== 'disabled') {
    securityLines.push(`  X-Frame-Options: ${frameOptions}`);
    result.totalSecurityHeaders++;
    result.estimatedBestPracticesImprovement += 6;
  }

  // 4. Referrer Policy (privacy protection)
  const referrerPolicy = security?.referrerPolicy || 'strict-origin-when-cross-origin';
  securityLines.push(`  Referrer-Policy: ${referrerPolicy}`);
  result.totalSecurityHeaders++;

  // 5. Strict Transport Security (HTTPS enforcement)
  if (security?.strictTransportSecurity !== false) {
    const hstsValue = security?.hstsMaxAge 
      ? `max-age=${security.hstsMaxAge}; includeSubDomains; preload`
      : 'max-age=63072000; includeSubDomains; preload';
    securityLines.push(`  Strict-Transport-Security: ${hstsValue}`);
    result.hstsEnabled = true;
    result.totalSecurityHeaders++;
    result.estimatedBestPracticesImprovement += 6;
  }

  // 6. Permissions Policy (feature control)
  const permissionsPolicy = security?.permissionsPolicy || generateDefaultPermissionsPolicy();
  securityLines.push(`  Permissions-Policy: ${permissionsPolicy}`);
  result.totalSecurityHeaders++;

  // 7. Cross-Origin-Opener-Policy (isolation)
  const coopPolicy = security?.crossOriginOpenerPolicy || 'same-origin-allow-popups';
  securityLines.push(`  Cross-Origin-Opener-Policy: ${coopPolicy}`);
  result.totalSecurityHeaders++;

  // 8. Cross-Origin-Resource-Policy (CORP)
  const corpPolicy = security?.crossOriginResourcePolicy || 'cross-origin';
  securityLines.push(`  Cross-Origin-Resource-Policy: ${corpPolicy}`);
  result.totalSecurityHeaders++;

  // 9. X-XSS-Protection (legacy XSS protection, disabled for modern CSP)
  securityLines.push('  X-XSS-Protection: 0');
  result.totalSecurityHeaders++;

  return securityLines;
}

/**
 * Generate default Content Security Policy for static sites
 * Optimized for performance and security without breaking functionality
 */
function generateDefaultCSP(): Record<string, string> {
  return {
    'default-src': '\'self\'',
    'script-src': '\'self\' \'unsafe-inline\' https://cdn.jsdelivr.net', // Allow inline scripts + hls.js CDN
    'style-src': '\'self\' \'unsafe-inline\'', // Allow inline styles for optimization
    'img-src': '\'self\' data: https: https://imagedelivery.net', // CF Images CDN for all images
    'font-src': '\'self\' data:', // Allow fonts from self and data URIs
    'connect-src': '\'self\' https://*.cloudflarestream.com', // API calls + CF Stream HLS chunks
    'media-src': '\'self\' https://*.cloudflarestream.com blob:', // CF Stream HLS video + MSE blobs
    'frame-src': '\'self\' https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com https://www.loom.com https://fast.wistia.net https://iframe.mediadelivery.net https://stream.mux.com https://www.dailymotion.com https://streamable.com https://player.twitch.tv https://clips.twitch.tv https://*.cloudflarestream.com', // Video embed sources
    'object-src': '\'none\'', // No plugins
    'base-uri': '\'self\'',
    'form-action': '\'self\'',
    'frame-ancestors': '\'none\'',
    'upgrade-insecure-requests': '',
  };
}

/**
 * Build CSP header string from directives object
 */
function buildCSPHeader(directives: Record<string, string>): string {
  return Object.entries(directives)
    .map(([key, value]) => value ? `${key} ${value}` : key)
    .join('; ');
}

/**
 * Generate default Permissions Policy for privacy and performance
 */
function generateDefaultPermissionsPolicy(): string {
  return [
    'geolocation=()',
    'camera=()',
    'microphone=()',
    'payment=()',
    'usb=()',
    'magnetometer=()',
    'gyroscope=()',
    'accelerometer=()',
    'ambient-light-sensor=()',
    'autoplay=(self)',
    'encrypted-media=(self)',
    'fullscreen=(self)',
    'picture-in-picture=(self)',
  ].join(', ');
}

/**
 * Analyze current security headers and estimate Best Practices score improvement
 */
export function analyzeSecurityHeaders(currentHeaders: Record<string, string>): {
  score: number;
  missingHeaders: string[];
  recommendations: string[];
} {
  const requiredHeaders = [
    'content-security-policy',
    'x-content-type-options',
    'x-frame-options',
    'referrer-policy',
    'strict-transport-security',
  ];

  const missingHeaders = requiredHeaders.filter(
    header => !Object.keys(currentHeaders).some(h => h.toLowerCase() === header)
  );

  const recommendations = [];
  
  if (missingHeaders.includes('content-security-policy')) {
    recommendations.push('Add Content-Security-Policy with require-trusted-types-for \'script\' for DOM XSS protection');
  }
  
  if (missingHeaders.includes('strict-transport-security')) {
    recommendations.push('Add Strict-Transport-Security for HTTPS enforcement');
  }

  // Each missing header costs ~6 points in Best Practices
  const score = Math.max(0, 100 - (missingHeaders.length * 6));

  return { score, missingHeaders, recommendations };
}
